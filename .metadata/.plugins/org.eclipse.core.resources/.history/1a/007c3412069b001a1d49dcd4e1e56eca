/* Module Name : HUSART
 * File Name   : HUSART_program.c
 * Author      : Bishoy Nabil
 * Version     : 1.0
 * Date        : 09/05/2020 */

#define NUMBER_OF_USART_CHANNELS         5

#include "STD_TYPES.h"
#include "RCC_interface.h"
#include "GPIO_interface.h"
#include "NVIC_interface.h"
#include "USART_interface.h"
#include "HUSART_interface.h"

typedef struct
{
	u8* pdata;
	u32 position;
	u32 size;
	u8  state;
}dataBuffer_t;

static dataBuffer_t txBuffer[NUMBER_OF_USART_CHANNELS];
static dataBuffer_t rxBuffer[NUMBER_OF_USART_CHANNELS];

static TxCBF_t appTxNotify[NUMBER_OF_USART_CHANNELS];
static RxCBF_t appRxNotify[NUMBER_OF_USART_CHANNELS];

extern Status HUSART_Init(u8 copy_u8USARTNum)
{
	Status Local_Status = IDLE;
	PinParam_t Tx_Pin;
	PinParam_t Rx_Pin;
	NVIC_t NVIC_Struct;
	NVIC_Struct.PendingFlag = DISABLE;
	NVIC_Struct.EnableBit   = ENABLE;
	Tx_Pin.Mode = OUTPUT_2MHZ_AF_PUSH_PULL;
	Rx_Pin.Mode = INPUT_FLOATING;

	switch(copy_u8USARTNum)
	{
	case USART1:
	{
		Tx_Pin.Port = PORTA;
		Rx_Pin.Port = PORTA;
		Tx_Pin.Pin = PIN9;
		Rx_Pin.Pin = PIN10;
		RCC_EnableAPB2Peripheral(IOPA);
		RCC_EnableAPB2Peripheral(USART1EN);
		NVIC_Struct.ID = NVIC_USART1;
	}break;
	case USART2:
	{
		Tx_Pin.Port = PORTA;
		Rx_Pin.Port = PORTA;
		Tx_Pin.Pin = PIN2;
		Rx_Pin.Pin = PIN3;
		RCC_EnableAPB2Peripheral(IOPA);
		RCC_EnableAPB1Peripheral(USART2EN);
		NVIC_Struct.ID = NVIC_USART2;
	}break;
	case USART3:
	{
		Tx_Pin.Port = PORTB;
		Rx_Pin.Port = PORTB;
		Tx_Pin.Pin = PIN10;
		Rx_Pin.Pin = PIN11;
		RCC_EnableAPB2Peripheral(IOPB);
		RCC_EnableAPB1Peripheral(USART3EN);
		NVIC_Struct.ID = NVIC_USART3;
	}break;
	case USART4:
	{
		Local_Status = ERROR;
	}break;
	case USART5:
	{
		Local_Status = ERROR;
	}break;
	}
	USART_Init(copy_u8USARTNum);
	NVIC_ControlPendingFlag(&NVIC_Struct);
	NVIC_ControlEnableInterrupt(&NVIC_Struct);
	DIO_Init(&Tx_Pin);
	DIO_Init(&Rx_Pin);
	return Local_Status;
	//Setup interrupts (clear pending, enable interrupt)
}
extern Status HUSART_Send(u8 copy_u8USARTNum, u8* copy_pu8Buffer, u16 copy_u16Length)
{
	Status Local_Status = IDLE;
	if((copy_u8USARTNum < 5) && (copy_pu8Buffer != NULL) && (copy_u16Length <= 1000))
		{
			if(txBuffer[copy_u8USARTNum].state == IDLE)
			{
				txBuffer[copy_u8USARTNum].pdata = copy_pu8Buffer;
				txBuffer[copy_u8USARTNum].position = 0;
				txBuffer[copy_u8USARTNum].size = copy_u16Length;
				txBuffer[copy_u8USARTNum].state = BUSY;

				USART_SetFlags(USART_1,TE);
				USART_Send(copy_u8USARTNum,txBuffer[copy_u8USARTNum].pdata[txBuffer[copy_u8USARTNum].position]);
				txBuffer[copy_u8USARTNum].position ++;
			}
			else
			{
				Local_Status = BUSY;
			}
		}
		else
		{
			Local_Status = ERROR;
		}
	return Local_Status;
}
extern Status HUSART_Receive(u8 copy_u8USARTNum, u8* copy_pu8Buffer, u16 copy_u16Length)
{
	Status Local_Status = IDLE;
	if((copy_u8USARTNum < 5) && (copy_pu8Buffer != NULL) && (copy_u16Length <= 1000))
	{
		if(rxBuffer[copy_u8USARTNum].state == IDLE)
		{
			rxBuffer[copy_u8USARTNum].pdata = copy_pu8Buffer;
			rxBuffer[copy_u8USARTNum].position = 0;
			rxBuffer[copy_u8USARTNum].size = copy_u16Length;
			rxBuffer[copy_u8USARTNum].state = BUSY;

			USART_SetFlags(USART_1,RE);
		}
		else
		{
			Local_Status = BUSY;
		}
	}
	else
	{
		Local_Status = ERROR;
	}
	return Local_Status;
}

extern Status HUSART_SetTxCBF(u8 copy_u8USARTNum, TxCBF_t copy_TxCBF)
{
	Status Local_Status = IDLE;
	if(copy_TxCBF && copy_u8USARTNum < 5)
	{
		appTxNotify[copy_u8USARTNum] = copy_TxCBF;
	}
	else
	{
		Local_Status = ERROR;
	}
	return Local_Status;
}
extern Status HUSART_SetRxCBF(u8 copy_u8USARTNum, RxCBF_t copy_RxCBF)
{
	Status Local_Status = IDLE;
	if(copy_RxCBF && copy_u8USARTNum < 5)
	{
		appRxNotify[copy_u8USARTNum] = copy_RxCBF;
	}
	else
	{
		Local_Status = ERROR;
	}
	return Local_Status;
}

void USART1_IRQHandler(void)
{
	u8 Local_TXEValue = 0;
	u8 Local_RXNEValue = 0;
	USART_ReadFlags(USART_1,TXE,&Local_TXEValue);
	USART_ReadFlags(USART_1,RXNE,&Local_RXNEValue);

	if(Local_TXEValue != 0)
	{
		if(txBuffer[USART1].size != txBuffer[USART1].position)
		{
			  USART_Send(USART_1,txBuffer[USART1].pdata[txBuffer[USART1].position]);
			  txBuffer->position ++;
		}
		else
		{
			txBuffer[USART1].pdata = NULL;
			txBuffer[USART1].size = 0;
			txBuffer[USART1].position = 0;
			txBuffer[USART1].state = IDLE;
  			appTxNotify[USART1]();
		}
	}
	if(Local_RXNEValue != 0)
	{
		if(rxBuffer[USART1].state == 0)
		{
			USART_Receive(USART_1,&(rxBuffer[USART1].pdata[rxBuffer[USART1].position]));
			rxBuffer[USART1].position ++;

			if(rxBuffer[USART1].position == rxBuffer[USART1].size)
			{
				rxBuffer[USART1].pdata = NULL;
				rxBuffer[USART1].size = 0;
				rxBuffer[USART1].position = 0;
				rxBuffer[USART1].state = IDLE;
				appRxNotify[USART1]();
			}
		}
		else
		{
			return;
		}
	}

}
